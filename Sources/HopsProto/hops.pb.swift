// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/hops.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Hops_SandboxState: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknown // = 0
  case starting // = 1
  case running // = 2
  case stopped // = 3
  case failed // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .starting
    case 2: self = .running
    case 3: self = .stopped
    case 4: self = .failed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .starting: return 1
    case .running: return 2
    case .stopped: return 3
    case .failed: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Hops_SandboxState] = [
    .unknown,
    .starting,
    .running,
    .stopped,
    .failed,
  ]

}

public enum Hops_NetworkAccess: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case disabled // = 0
  case outbound // = 1
  case loopback // = 2
  case full // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .disabled
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .disabled
    case 1: self = .outbound
    case 2: self = .loopback
    case 3: self = .full
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .disabled: return 0
    case .outbound: return 1
    case .loopback: return 2
    case .full: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Hops_NetworkAccess] = [
    .disabled,
    .outbound,
    .loopback,
    .full,
  ]

}

public enum Hops_InputType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case run // = 0
  case stdin // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .run
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .run
    case 1: self = .stdin
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .run: return 0
    case .stdin: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Hops_InputType] = [
    .run,
    .stdin,
  ]

}

public enum Hops_OutputType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case stdout // = 0
  case stderr // = 1
  case exit // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .stdout
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .stdout
    case 1: self = .stderr
    case 2: self = .exit
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .stdout: return 0
    case .stderr: return 1
    case .exit: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Hops_OutputType] = [
    .stdout,
    .stderr,
    .exit,
  ]

}

public struct Hops_RunRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var command: [String] = []

  public var policyPath: String {
    get {return _policyPath ?? String()}
    set {_policyPath = newValue}
  }
  /// Returns true if `policyPath` has been explicitly set.
  public var hasPolicyPath: Bool {return self._policyPath != nil}
  /// Clears the value of `policyPath`. Subsequent reads from it will return its default value.
  public mutating func clearPolicyPath() {self._policyPath = nil}

  public var inlinePolicy: Hops_Policy {
    get {return _inlinePolicy ?? Hops_Policy()}
    set {_inlinePolicy = newValue}
  }
  /// Returns true if `inlinePolicy` has been explicitly set.
  public var hasInlinePolicy: Bool {return self._inlinePolicy != nil}
  /// Clears the value of `inlinePolicy`. Subsequent reads from it will return its default value.
  public mutating func clearInlinePolicy() {self._inlinePolicy = nil}

  public var environment: Dictionary<String,String> = [:]

  public var workingDirectory: String {
    get {return _workingDirectory ?? String()}
    set {_workingDirectory = newValue}
  }
  /// Returns true if `workingDirectory` has been explicitly set.
  public var hasWorkingDirectory: Bool {return self._workingDirectory != nil}
  /// Clears the value of `workingDirectory`. Subsequent reads from it will return its default value.
  public mutating func clearWorkingDirectory() {self._workingDirectory = nil}

  public var keep: Bool = false

  public var allocateTty: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _policyPath: String? = nil
  fileprivate var _inlinePolicy: Hops_Policy? = nil
  fileprivate var _workingDirectory: String? = nil
}

public struct Hops_RunResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sandboxID: String = String()

  public var pid: Int32 = 0

  public var success: Bool = false

  public var error: String {
    get {return _error ?? String()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _error: String? = nil
}

public struct Hops_StopRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sandboxID: String = String()

  public var force: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Hops_StopResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var error: String {
    get {return _error ?? String()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _error: String? = nil
}

public struct Hops_ListRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var includeStopped: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Hops_ListResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sandboxes: [Hops_SandboxInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Hops_StatusRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sandboxID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Hops_SandboxStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sandboxID: String = String()

  public var pid: Int32 = 0

  public var state: Hops_SandboxState = .unknown

  public var command: [String] = []

  public var startTime: Int64 = 0

  public var endTime: Int64 {
    get {return _endTime ?? 0}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  public var exitCode: Int32 {
    get {return _exitCode ?? 0}
    set {_exitCode = newValue}
  }
  /// Returns true if `exitCode` has been explicitly set.
  public var hasExitCode: Bool {return self._exitCode != nil}
  /// Clears the value of `exitCode`. Subsequent reads from it will return its default value.
  public mutating func clearExitCode() {self._exitCode = nil}

  public var resourceUsage: Hops_ResourceUsage {
    get {return _resourceUsage ?? Hops_ResourceUsage()}
    set {_resourceUsage = newValue}
  }
  /// Returns true if `resourceUsage` has been explicitly set.
  public var hasResourceUsage: Bool {return self._resourceUsage != nil}
  /// Clears the value of `resourceUsage`. Subsequent reads from it will return its default value.
  public mutating func clearResourceUsage() {self._resourceUsage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _endTime: Int64? = nil
  fileprivate var _exitCode: Int32? = nil
  fileprivate var _resourceUsage: Hops_ResourceUsage? = nil
}

public struct Hops_SandboxInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sandboxID: String = String()

  public var pid: Int32 = 0

  public var state: Hops_SandboxState = .unknown

  public var command: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Hops_Policy: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sandbox: Hops_SandboxConfig {
    get {return _sandbox ?? Hops_SandboxConfig()}
    set {_sandbox = newValue}
  }
  /// Returns true if `sandbox` has been explicitly set.
  public var hasSandbox: Bool {return self._sandbox != nil}
  /// Clears the value of `sandbox`. Subsequent reads from it will return its default value.
  public mutating func clearSandbox() {self._sandbox = nil}

  public var capabilities: Hops_Capabilities {
    get {return _capabilities ?? Hops_Capabilities()}
    set {_capabilities = newValue}
  }
  /// Returns true if `capabilities` has been explicitly set.
  public var hasCapabilities: Bool {return self._capabilities != nil}
  /// Clears the value of `capabilities`. Subsequent reads from it will return its default value.
  public mutating func clearCapabilities() {self._capabilities = nil}

  public var resources: Hops_ResourceLimits {
    get {return _resources ?? Hops_ResourceLimits()}
    set {_resources = newValue}
  }
  /// Returns true if `resources` has been explicitly set.
  public var hasResources: Bool {return self._resources != nil}
  /// Clears the value of `resources`. Subsequent reads from it will return its default value.
  public mutating func clearResources() {self._resources = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sandbox: Hops_SandboxConfig? = nil
  fileprivate var _capabilities: Hops_Capabilities? = nil
  fileprivate var _resources: Hops_ResourceLimits? = nil
}

public struct Hops_SandboxConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var root: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Hops_Capabilities: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var network: Hops_NetworkAccess = .disabled

  public var filesystem: Hops_FilesystemCapabilities {
    get {return _filesystem ?? Hops_FilesystemCapabilities()}
    set {_filesystem = newValue}
  }
  /// Returns true if `filesystem` has been explicitly set.
  public var hasFilesystem: Bool {return self._filesystem != nil}
  /// Clears the value of `filesystem`. Subsequent reads from it will return its default value.
  public mutating func clearFilesystem() {self._filesystem = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _filesystem: Hops_FilesystemCapabilities? = nil
}

public struct Hops_FilesystemCapabilities: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var read: [String] = []

  public var write: [String] = []

  public var execute: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Hops_ResourceLimits: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cpus: Int32 = 0

  public var memory: String = String()

  public var maxProcesses: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Hops_ResourceUsage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cpuPercent: Double = 0

  public var memoryBytes: UInt64 = 0

  public var processCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Hops_InputChunk: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sandboxID: String {
    get {return _storage._sandboxID}
    set {_uniqueStorage()._sandboxID = newValue}
  }

  public var type: Hops_InputType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var data: Data {
    get {return _storage._data}
    set {_uniqueStorage()._data = newValue}
  }

  public var runRequest: Hops_RunRequest {
    get {return _storage._runRequest ?? Hops_RunRequest()}
    set {_uniqueStorage()._runRequest = newValue}
  }
  /// Returns true if `runRequest` has been explicitly set.
  public var hasRunRequest: Bool {return _storage._runRequest != nil}
  /// Clears the value of `runRequest`. Subsequent reads from it will return its default value.
  public mutating func clearRunRequest() {_uniqueStorage()._runRequest = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Hops_OutputChunk: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sandboxID: String = String()

  public var type: Hops_OutputType = .stdout

  public var data: Data = Data()

  public var timestamp: Int64 = 0

  public var exitCode: Int32 {
    get {return _exitCode ?? 0}
    set {_exitCode = newValue}
  }
  /// Returns true if `exitCode` has been explicitly set.
  public var hasExitCode: Bool {return self._exitCode != nil}
  /// Clears the value of `exitCode`. Subsequent reads from it will return its default value.
  public mutating func clearExitCode() {self._exitCode = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _exitCode: Int32? = nil
}

public struct Hops_DaemonStatusRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Hops_DaemonStatusResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pid: Int32 = 0

  public var startTime: Int64 = 0

  public var activeSandboxes: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "hops"

extension Hops_SandboxState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SANDBOX_STATE_UNKNOWN\0\u{1}SANDBOX_STATE_STARTING\0\u{1}SANDBOX_STATE_RUNNING\0\u{1}SANDBOX_STATE_STOPPED\0\u{1}SANDBOX_STATE_FAILED\0")
}

extension Hops_NetworkAccess: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0NETWORK_ACCESS_DISABLED\0\u{1}NETWORK_ACCESS_OUTBOUND\0\u{1}NETWORK_ACCESS_LOOPBACK\0\u{1}NETWORK_ACCESS_FULL\0")
}

extension Hops_InputType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0INPUT_TYPE_RUN\0\u{1}INPUT_TYPE_STDIN\0")
}

extension Hops_OutputType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0OUTPUT_TYPE_STDOUT\0\u{1}OUTPUT_TYPE_STDERR\0\u{1}OUTPUT_TYPE_EXIT\0")
}

extension Hops_RunRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RunRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}command\0\u{3}policy_path\0\u{3}inline_policy\0\u{1}environment\0\u{3}working_directory\0\u{1}keep\0\u{3}allocate_tty\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.command) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._policyPath) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._inlinePolicy) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.environment) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._workingDirectory) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.keep) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.allocateTty) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.command.isEmpty {
      try visitor.visitRepeatedStringField(value: self.command, fieldNumber: 1)
    }
    try { if let v = self._policyPath {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._inlinePolicy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.environment.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.environment, fieldNumber: 4)
    }
    try { if let v = self._workingDirectory {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    if self.keep != false {
      try visitor.visitSingularBoolField(value: self.keep, fieldNumber: 6)
    }
    if self.allocateTty != false {
      try visitor.visitSingularBoolField(value: self.allocateTty, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Hops_RunRequest, rhs: Hops_RunRequest) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs._policyPath != rhs._policyPath {return false}
    if lhs._inlinePolicy != rhs._inlinePolicy {return false}
    if lhs.environment != rhs.environment {return false}
    if lhs._workingDirectory != rhs._workingDirectory {return false}
    if lhs.keep != rhs.keep {return false}
    if lhs.allocateTty != rhs.allocateTty {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Hops_RunResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RunResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}sandbox_id\0\u{1}pid\0\u{1}success\0\u{1}error\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sandboxID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pid) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sandboxID.isEmpty {
      try visitor.visitSingularStringField(value: self.sandboxID, fieldNumber: 1)
    }
    if self.pid != 0 {
      try visitor.visitSingularInt32Field(value: self.pid, fieldNumber: 2)
    }
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 3)
    }
    try { if let v = self._error {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Hops_RunResponse, rhs: Hops_RunResponse) -> Bool {
    if lhs.sandboxID != rhs.sandboxID {return false}
    if lhs.pid != rhs.pid {return false}
    if lhs.success != rhs.success {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Hops_StopRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StopRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}sandbox_id\0\u{1}force\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sandboxID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sandboxID.isEmpty {
      try visitor.visitSingularStringField(value: self.sandboxID, fieldNumber: 1)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Hops_StopRequest, rhs: Hops_StopRequest) -> Bool {
    if lhs.sandboxID != rhs.sandboxID {return false}
    if lhs.force != rhs.force {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Hops_StopResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StopResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Hops_StopResponse, rhs: Hops_StopResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Hops_ListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}include_stopped\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.includeStopped) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.includeStopped != false {
      try visitor.visitSingularBoolField(value: self.includeStopped, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Hops_ListRequest, rhs: Hops_ListRequest) -> Bool {
    if lhs.includeStopped != rhs.includeStopped {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Hops_ListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}sandboxes\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sandboxes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sandboxes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sandboxes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Hops_ListResponse, rhs: Hops_ListResponse) -> Bool {
    if lhs.sandboxes != rhs.sandboxes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Hops_StatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatusRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}sandbox_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sandboxID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sandboxID.isEmpty {
      try visitor.visitSingularStringField(value: self.sandboxID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Hops_StatusRequest, rhs: Hops_StatusRequest) -> Bool {
    if lhs.sandboxID != rhs.sandboxID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Hops_SandboxStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SandboxStatus"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}sandbox_id\0\u{1}pid\0\u{1}state\0\u{1}command\0\u{3}start_time\0\u{3}end_time\0\u{3}exit_code\0\u{3}resource_usage\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sandboxID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pid) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.command) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.startTime) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self._endTime) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self._exitCode) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._resourceUsage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sandboxID.isEmpty {
      try visitor.visitSingularStringField(value: self.sandboxID, fieldNumber: 1)
    }
    if self.pid != 0 {
      try visitor.visitSingularInt32Field(value: self.pid, fieldNumber: 2)
    }
    if self.state != .unknown {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 3)
    }
    if !self.command.isEmpty {
      try visitor.visitRepeatedStringField(value: self.command, fieldNumber: 4)
    }
    if self.startTime != 0 {
      try visitor.visitSingularInt64Field(value: self.startTime, fieldNumber: 5)
    }
    try { if let v = self._endTime {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._exitCode {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._resourceUsage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Hops_SandboxStatus, rhs: Hops_SandboxStatus) -> Bool {
    if lhs.sandboxID != rhs.sandboxID {return false}
    if lhs.pid != rhs.pid {return false}
    if lhs.state != rhs.state {return false}
    if lhs.command != rhs.command {return false}
    if lhs.startTime != rhs.startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs._exitCode != rhs._exitCode {return false}
    if lhs._resourceUsage != rhs._resourceUsage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Hops_SandboxInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SandboxInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}sandbox_id\0\u{1}pid\0\u{1}state\0\u{1}command\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sandboxID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pid) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.command) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sandboxID.isEmpty {
      try visitor.visitSingularStringField(value: self.sandboxID, fieldNumber: 1)
    }
    if self.pid != 0 {
      try visitor.visitSingularInt32Field(value: self.pid, fieldNumber: 2)
    }
    if self.state != .unknown {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 3)
    }
    if !self.command.isEmpty {
      try visitor.visitRepeatedStringField(value: self.command, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Hops_SandboxInfo, rhs: Hops_SandboxInfo) -> Bool {
    if lhs.sandboxID != rhs.sandboxID {return false}
    if lhs.pid != rhs.pid {return false}
    if lhs.state != rhs.state {return false}
    if lhs.command != rhs.command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Hops_Policy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Policy"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}sandbox\0\u{1}capabilities\0\u{1}resources\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sandbox) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._capabilities) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._resources) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sandbox {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._capabilities {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._resources {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Hops_Policy, rhs: Hops_Policy) -> Bool {
    if lhs._sandbox != rhs._sandbox {return false}
    if lhs._capabilities != rhs._capabilities {return false}
    if lhs._resources != rhs._resources {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Hops_SandboxConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SandboxConfig"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}root\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.root) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.root.isEmpty {
      try visitor.visitSingularStringField(value: self.root, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Hops_SandboxConfig, rhs: Hops_SandboxConfig) -> Bool {
    if lhs.root != rhs.root {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Hops_Capabilities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Capabilities"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}network\0\u{1}filesystem\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.network) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._filesystem) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.network != .disabled {
      try visitor.visitSingularEnumField(value: self.network, fieldNumber: 1)
    }
    try { if let v = self._filesystem {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Hops_Capabilities, rhs: Hops_Capabilities) -> Bool {
    if lhs.network != rhs.network {return false}
    if lhs._filesystem != rhs._filesystem {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Hops_FilesystemCapabilities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FilesystemCapabilities"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}read\0\u{1}write\0\u{1}execute\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.read) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.write) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.execute) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.read.isEmpty {
      try visitor.visitRepeatedStringField(value: self.read, fieldNumber: 1)
    }
    if !self.write.isEmpty {
      try visitor.visitRepeatedStringField(value: self.write, fieldNumber: 2)
    }
    if !self.execute.isEmpty {
      try visitor.visitRepeatedStringField(value: self.execute, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Hops_FilesystemCapabilities, rhs: Hops_FilesystemCapabilities) -> Bool {
    if lhs.read != rhs.read {return false}
    if lhs.write != rhs.write {return false}
    if lhs.execute != rhs.execute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Hops_ResourceLimits: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResourceLimits"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}cpus\0\u{1}memory\0\u{3}max_processes\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.cpus) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.memory) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.maxProcesses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cpus != 0 {
      try visitor.visitSingularInt32Field(value: self.cpus, fieldNumber: 1)
    }
    if !self.memory.isEmpty {
      try visitor.visitSingularStringField(value: self.memory, fieldNumber: 2)
    }
    if self.maxProcesses != 0 {
      try visitor.visitSingularInt32Field(value: self.maxProcesses, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Hops_ResourceLimits, rhs: Hops_ResourceLimits) -> Bool {
    if lhs.cpus != rhs.cpus {return false}
    if lhs.memory != rhs.memory {return false}
    if lhs.maxProcesses != rhs.maxProcesses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Hops_ResourceUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResourceUsage"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cpu_percent\0\u{3}memory_bytes\0\u{3}process_count\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.cpuPercent) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.memoryBytes) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.processCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cpuPercent.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.cpuPercent, fieldNumber: 1)
    }
    if self.memoryBytes != 0 {
      try visitor.visitSingularUInt64Field(value: self.memoryBytes, fieldNumber: 2)
    }
    if self.processCount != 0 {
      try visitor.visitSingularInt32Field(value: self.processCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Hops_ResourceUsage, rhs: Hops_ResourceUsage) -> Bool {
    if lhs.cpuPercent != rhs.cpuPercent {return false}
    if lhs.memoryBytes != rhs.memoryBytes {return false}
    if lhs.processCount != rhs.processCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Hops_InputChunk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InputChunk"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}sandbox_id\0\u{1}type\0\u{1}data\0\u{3}run_request\0")

  fileprivate class _StorageClass {
    var _sandboxID: String = String()
    var _type: Hops_InputType = .run
    var _data: Data = Data()
    var _runRequest: Hops_RunRequest? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sandboxID = source._sandboxID
      _type = source._type
      _data = source._data
      _runRequest = source._runRequest
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._sandboxID) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 3: try { try decoder.decodeSingularBytesField(value: &_storage._data) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._runRequest) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._sandboxID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sandboxID, fieldNumber: 1)
      }
      if _storage._type != .run {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 2)
      }
      if !_storage._data.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._data, fieldNumber: 3)
      }
      try { if let v = _storage._runRequest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Hops_InputChunk, rhs: Hops_InputChunk) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sandboxID != rhs_storage._sandboxID {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._data != rhs_storage._data {return false}
        if _storage._runRequest != rhs_storage._runRequest {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Hops_OutputChunk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutputChunk"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}sandbox_id\0\u{1}type\0\u{1}data\0\u{1}timestamp\0\u{3}exit_code\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sandboxID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._exitCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sandboxID.isEmpty {
      try visitor.visitSingularStringField(value: self.sandboxID, fieldNumber: 1)
    }
    if self.type != .stdout {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 4)
    }
    try { if let v = self._exitCode {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Hops_OutputChunk, rhs: Hops_OutputChunk) -> Bool {
    if lhs.sandboxID != rhs.sandboxID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.data != rhs.data {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs._exitCode != rhs._exitCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Hops_DaemonStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DaemonStatusRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Hops_DaemonStatusRequest, rhs: Hops_DaemonStatusRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Hops_DaemonStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DaemonStatusResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}pid\0\u{3}start_time\0\u{3}active_sandboxes\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pid) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.startTime) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.activeSandboxes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pid != 0 {
      try visitor.visitSingularInt32Field(value: self.pid, fieldNumber: 1)
    }
    if self.startTime != 0 {
      try visitor.visitSingularInt64Field(value: self.startTime, fieldNumber: 2)
    }
    if self.activeSandboxes != 0 {
      try visitor.visitSingularInt32Field(value: self.activeSandboxes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Hops_DaemonStatusResponse, rhs: Hops_DaemonStatusResponse) -> Bool {
    if lhs.pid != rhs.pid {return false}
    if lhs.startTime != rhs.startTime {return false}
    if lhs.activeSandboxes != rhs.activeSandboxes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
